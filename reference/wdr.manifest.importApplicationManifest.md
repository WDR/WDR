---
layout: page
tagline: WDR Reference
title: importApplicationManifest
---

    importApplicationManifest( <applicationManifestFilename> [, <variables> [, <listener>, [, <manifestPath>] ] ] )

Imports application manifest and assures that the application is installed with provided options. The application may be installed, updated or no action may be performed if the application is up to date.

The idea behind manifests is described on a [page dedicated to manifests](../manifests.html).

The ``importApplicationManifest`` function:

* parses the input manifest file
* substitutes variable references with their values
* for each application listed in the manifest, it calculates checksum of application deployment options and the actual application archive
* checksums are being compared with checksums saved in configuration during previous deployment
* if the application has not been deployed yet, it is being installed
* if the application was deployed before and checksums do not match the ones stored in configuration, the application is being updated
* if the application was deployed before and checksums in WAS configuration match checksums calculated above, the install/update step is being skipped
* if application was installed/updated, its manifest & EAR checksum is being saved in WAS configuration as custom property of the deployment

#### Arguments

_applicationManifestFilename_

path to application manifest file, relative to `manifestPath`

_variables_

dictionary of variables (and filters) being used during variable expansion

_listener_

listener objects receiving callbacks on different actions being performed during application manifest import

_manifestPath_

list of paths where the `applicationManifestFile` is going to be looked up; optional, defaults to reversed Jython's `sys.path`

#### Result

List of application names that have been affected (installed or updated) during manifest import. Application manifest may describe deployment of one or more applications. Names of applications which haven't been installed/updated will not be included in the returned list.

#### Result

List of application names installed or updated during manifest processing.

#### Notes

Idempotency of ``importApplicationManifest`` function relies on value of `wdr.checksum` custom property being added to `Deployment/ApplicationDeployment` object after successful install/update operation. The `wdr.checksum` property is visible in AdminConsole from version 8.0 of WebSphere Application Server. Regardless of product version, it is always possible to access it via scrtipt:

{% highlight python %}
appName = 'DefaultApplication'
checksums = getid1('/Deployment:%s/ApplicationDeployment:/Property:wdr.checksum/' % appName).value

print 'Checksum of %s is %s' % (appName, checksums)
{% endhighlight %}

The value of `wdr.checksum` consists of checksum of application binary and checksum of manifest file, which means that after change of any of these 2 files and invoking `importApplicationManifest` again, the application will be updated.

> When installing/updating the application via AdminConsole or via wsadmin's insta/update functions, the ``wdr.checksum`` will not updated. Therefore mixing manual or AdminApp-based installs/updates with `importApplicationManifest` usage may break imdepotency of `importApplicationManifest` function.
> 
> Generally, manual deployments are only recommended when the structure of the application has changed, the changes need to be reflected in the manifest and your preferred way of authoring application manifests is via customising manifests generated by [exportApplicationManifestToFile](wdr.tools.exportApplicationManifestToFile.html) function. Then the sequence is:
>
> * install manually
> * export application manifest
> * customise manifest for your environment
> * reinstall again by importing the manifest

#### Examples

The example demonstrates installing or updating the ``DefaultApplication`` provided with WebSphere Application Server.

The application manifest may look as follows:

    DefaultApplication ../applications/DefaultApplication.ear
    	DataSourceFor20CMPBeans
    		Increment EJB module;Increment;Increment.jar,META-INF/ejb-jar.xml;jdbc/DefaultEJBTimerDataSource;cmpBinding.perConnectionFactory;;
    	DataSourceFor20EJBModules
    		Increment EJB module;Increment.jar,META-INF/ejb-jar.xml;jdbc/DefaultEJBTimerDataSource;cmpBinding.perConnectionFactory;;;
    	MapModulesToServers
    		Increment EJB module;Increment.jar,META-INF/ejb-jar.xml;$[deploymentTargets]
    		Default Web Application;DefaultWebApplication.war,WEB-INF/web.xml;$[deploymentTargets]+$[webServers]
    	MapRolesToUsers
    		All Role;AppDeploymentOption.No;AppDeploymentOption.No;;;AppDeploymentOption.Yes;;
    	MapWebModToVH
    		Default Web Application;DefaultWebApplication.war,WEB-INF/web.xml;$[virtualHost]
    	asyncRequestDispatchType DISABLED
    	createMBeansForResources 
    	distributeApp 
    	filepermission .*\.dll=755#.*\.so=755#.*\.a=755#.*\.sl=755
    	noallowDispatchRemoteInclude 
    	noallowServiceRemoteInclude 
    	noprocessEmbeddedConfig 
    	noreloadEnabled 
    	nouseAutoLink 
    	nouseMetaDataFromBinary 
    	nodeployws 
    	nodeployejb 
    	nopreCompileJSPs 
    	validateinstall warn

The first line in the manifest above defines application name (as it is visible in AdminConsole) and path to application archive (EAR, WAR, ejb-JAR). The path is relative to manifest file (not current working directory nor manifestPath).

The remaining lines represent options being passed to AdminApp install/update functions.

Please note references to ``$[deploymentTargets]``, ``$[webServers]`` and ``$[virtualHost]`` variable references.

The actual values of these variables are being passed as a dictionary to ``importApplicationManifest`` call.

The `VerboseListener` object will receive callbacks on events that occur during manifest processing.

Lastly, a `manifestPath` list is being passed to `importApplicationManifest` which will instruct the import process to search for application manifest in `manifests` directory. Considering the fact that the manifest points to `../applications/DefaultApplication.ear` binary, the directory structure must look as follows:

    importApplicationManifestExample.py
    manifests/DefaultApplication.wdra
    applications/DefaultApplication.ear

{% highlight python %}
# importApplicationManifestExample.py

class VerboseListener( ApplicationDeploymentListener ):
    def beforeInstall( self, appName, archivePath ):
        print 'about to install application %s from %s' % (appName, archivePath)
    def beforeUpdate( self, appName, archivePath ):
        print 'about to update application %s from %s' % (appName, archivePath)
    def afterInstall( self, appName, archivePath ):
        print 'installed application %s from %s' % (appName, archivePath)
    def afterUpdate( self, appName, archivePath ):
        print 'updated application %s from %s' % (appName, archivePath)
    def skippedUpdate( self, appName, archivePath ):
        print 'skipped application installation/update of %s from %s' % (appName, archivePath)

# these environment-specific values should be loaded from external file/script:
cellName = 'wdrCell'
clusterName = 'wdrCluster'
webServers = [ [ 'webServerNode01', 'webServer01' ], [ 'webServerNode02', 'webServer02' ] ]
virtualHost = 'wdr_host'
try:
    variables = {}
    variables['virtualHost'] = virtualHost
    # store 'WebSphere:cell=wdrCell,cluster=wdrCluster' under 'deploymentTargets' key
    variables[ 'deploymentTargets' ] = 'WebSphere:cell=%s,cluster=%s' % ( cellName, clusterName )
    # the following line will store 'webServers' entry with value of:
    # 'WebSphere:node=webServerNode01,server=webServer01+WebSphere:node=webServerNode02,server=webServer02'
    variables[ 'webServers' ] = '+'.join( [ 'WebSphere:node=%s,server=%s' % tuple(ws) for ws in webServers ] )
    importApplicationManifest('DefaultApplication.wdra', variables, VerboseListener(), ['manifests'])
    save()
    sync()
finally:
    reset()
{% endhighlight %}

